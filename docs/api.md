---
id: doc1
title: Parsica API
sidebar_label: Parsica API
---

<!-- DO NOT EDIT! This file is autogenerated. -->

## Characters

### char

Parse a single character.




```php
function char(string $c) : Parser
```


### controlChar

Parse a control character (a non-printing character of the Latin-1 subset of Unicode).


```php
function controlChar() : Parser
```


### upperChar

Parse an uppercase character A-Z.


```php
function upperChar() : Parser
```


### lowerChar

Parse a lowercase character a-z.


```php
function lowerChar() : Parser
```


### alphaChar

Parse an uppercase or lowercase character A-Z, a-z.


```php
function alphaChar() : Parser
```


### alphaNumChar

Parse an alpha or numeric character A-Z, a-z, 0-9.


```php
function alphaNumChar() : Parser
```


### printChar

Parse a printable ASCII char.


```php
function printChar() : Parser
```


### punctuationChar

Parse a single punctuation character !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~


```php
function punctuationChar() : Parser
```


### digitChar

Parse 0-9. Returns the digit as a string. Use ->map('intval')
or similar to cast it to a numeric type.


```php
function digitChar() : Parser
```


### binDigitChar

Parse a binary character 0 or 1.


```php
function binDigitChar() : Parser
```


### octDigitChar

Parse an octodecimal character 0-7.



```php
function octDigitChar() : Parser
```


### hexDigitChar

Parse a hexadecimal numeric character 0123456789abcdefABCDEF.


```php
function hexDigitChar() : Parser
```



---

## Combinators

### identity

Identity parser, returns the Parser as is.




```php
function identity(Parser $parser) : Parser
```


### pure

A parser that will have the argument as its output, no matter what the input was. It doesn't consume any input.




```php
function pure($output) : Parser
```


### optional

Optionally parse something, but still succeed if the thing is not there




```php
function optional(Parser $parser) : Parser
```


### bind

Create a parser that takes the output from the first parser (if successful) and feeds it to the callable. The callable
must return another parser. If the first parser fails, the first parser is returned.

This is a monadic bind aka flatmap.




```php
function bind(Parser $parser, callable $f) : Parser
```


### sequence

Parse something, then follow by something else. Ignore the result of the first parser and return the result of the
second parser.




```php
function sequence(Parser $first, Parser $second) : Parser
```


### keepFirst

Sequence two parsers, and return the output of the first one.


```php
function keepFirst(Parser $first, Parser $second) : Parser
```


### keepSecond

Sequence two parsers, and return the output of the second one.

```php
function keepSecond(Parser $first, Parser $second) : Parser
```


### either

Either parse the first thing or the second thing





```php
function either(Parser $first, Parser $second) : Parser
```


### append

Combine the parser with another parser of the same type, which will cause the results to be appended.




```php
function append(Parser $left, Parser $right) : Parser
```


### assemble

Append all the passed parsers.




```php
function assemble(Parser ...$parsers) : Parser
```


### collect

Parse into an array that consists of the results of all parsers.




```php
function collect(Parser ...$parsers) : Parser
```


### any

Tries each parser one by one, returning the result of the first one that succeeds.




```php
function any(Parser ...$parsers) : Parser
```


### atLeastOne

One or more repetitions of Parser





```php
function atLeastOne(Parser $parser) : Parser
```


### repeat

Parse something exactly n times






```php
function repeat(int $n, Parser $parser) : Parser
```


### many

Parse something zero or more times, and output an array of the successful outputs.

```php
function many(Parser $parser) : Parser
```


### some

Parse something one or more times, and output an array of the successful outputs.


```php
function some(Parser $parser) : Parser
```


### between

Parse $open, followed by $middle, followed by $close, and return the result of $middle. Useful for eg. "(value)".




```php
function between(Parser $open, Parser $middle, Parser $close) : Parser
```



---

## Numeric

### float

Parse a float. Returns the float as a string. Use ->map('floatval')
or similar to cast it to a numeric type.



```php
function float() : Parser
```



---

## Numeric

### isEqual

Creates an equality predicate


```php
function isEqual(string $x) : callable
```


### notPred

Negates a predicate.



```php
function notPred(callable $predicate) : callable
```


### andPred

Boolean And predicate.



```php
function andPred(callable $first, callable $second) : callable
```


### orPred

Boolean Or predicate.



```php
function orPred(callable $first, callable $second) : callable
```


### isCharCode

Predicate that checks if a character is in an array of character codes.



```php
function isCharCode(array $chars) : callable
```


### isSpace

Returns true for a space character, and the control characters \t, \n, \r, \f, \v.


```php
function isSpace() : callable
```


### isHSpace

Like 'isSpace', but does not accept newlines and carriage returns.


```php
function isHSpace() : callable
```


### isDigit

True for 0-9


```php
function isDigit() : callable
```


### isControl

Control character predicate (a non-printing character of the Latin-1 subset of Unicode).


```php
function isControl() : callable
```


### isBlank

Returns true for a space or a tab character


```php
function isBlank()
```


### isWhitespace

Returns true for a space character, and \t, \n, \r, \f, \v.


```php
function isWhitespace()
```


### isUpper

Returns true for an uppercase character A-Z.


```php
function isUpper()
```


### isLower

Returns true for a lowercase character a-z.


```php
function isLower()
```


### isAlpha

Returns true for an uppercase or lowercase character A-Z, a-z.


```php
function isAlpha()
```


### isAlphaNum

Returns true for an alpha or numeric character A-Z, a-z, 0-9.


```php
function isAlphaNum()
```


### isHexDigit

Returns true if the given character is a hexadecimal numeric character 0123456789abcdefABCDEF.


```php
function isHexDigit()
```


### isPrintable

Returns true if the given character is a printable ASCII char.


```php
function isPrintable()
```


### isPunctuation

Returns true if the given character is a punctuation character !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~


```php
function isPunctuation()
```



---

## Primitives

### satisfy

A parser that satisfies a predicate. Useful as a building block for writing things like char(), digit()...




```php
function satisfy(callable $predicate) : Parser
```


### skipWhile

Skip 0 or more characters as long as the predicate holds.




```php
function skipWhile(callable $predicate) : Parser
```


### skipWhile1

Skip 1 or more characters as long as the predicate holds.




```php
function skipWhile1(callable $predicate) : Parser
```


### takeWhile

Keep parsing 0 or more characters as long as the predicate holds.




```php
function takeWhile(callable $predicate) : Parser
```


### takeWhile1

Keep parsing 1 or more characters as long as the predicate holds.




```php
function takeWhile1(callable $predicate) : Parser
```


### anySingle

Parse and return a single character of anything.



```php
function anySingle() : Parser
```


### anything

Parse and return a single character of anything.


```php
function anything() : Parser
```


### anySingleBut

Match any character but the given one.



```php
function anySingleBut(string $x) : Parser
```


### oneOf

Succeeds if the current character is in the supplied list of characters. Returns the parsed character.




```php
function oneOf(array $chars) : Parser
```


### oneOfS

A compact form of 'oneOf'.
oneOfS("abc") == oneOf(['a', 'b', 'c'])




```php
function oneOfS(string $chars) : Parser
```


### noneOf

The dual of 'oneOf'. Succeeds if the current character is not in the supplied list of characters. Returns the
parsed character.




```php
function noneOf(array $chars) : Parser
```


### noneOfS

A compact form of 'noneOf'.
noneOfS("abc") == noneOf(['a', 'b', 'c'])




```php
function noneOfS(string $chars) : Parser
```


### takeRest

Consume the rest of the input and return it as a string. This parser never fails, but may return the empty string.


```php
function takeRest() : Parser
```


### nothing

Parse nothing, but still succeed.

This serves as the zero parser in `append()` operations.

```php
function nothing() : Parser
```


### everything

Parse everything; that is, consume the rest of the input until the end.

```php
function everything() : Parser
```


### success

Always succeed, no matter what the input was.

```php
function success() : Parser
```


### failure

Always fail, no matter what the input was.

```php
function failure() : Parser
```


### eof

Parse the end of the input


```php
function eof() : Parser
```



---

## Recursion

### recursive

Create a recursive parser. Used in combination with recurse(Parser).

For an example see {@see RecursiveParserTest}.


```php
function recursive() : Parser
```



---

## Space

### space

Parse a single space character.


```php
function space() : Parser
```


### tab

Parse a single tab character.


```php
function tab() : Parser
```


### blank

Parse a space or tab.


```php
function blank() : Parser
```


### whitespace

Parse a space character, and \t, \n, \r, \f, \v.


```php
function whitespace() : Parser
```


### newline

Parse a newline character.


```php
function newline() : Parser
```


### crlf

Parse a carriage return character and a newline character. Return the two characters. {\r\n}

```php
function crlf() : Parser
```


### eol

Parse a newline or a crlf.


```php
function eol() : Parser
```


### skipSpace

Skip zero or more white space characters.


```php
function skipSpace() : Parser
```


### skipHSpace

Like 'skipSpace', but does not accept newlines and carriage returns.


```php
function skipHSpace() : Parser
```


### skipSpace1

Skip one or more white space characters.


```php
function skipSpace1() : Parser
```


### skipHSpace1

Like 'skipSpace1', but does not accept newlines and carriage returns.


```php
function skipHSpace1() : Parser
```



---

## Strings

### string

Parse a non-empty string.



```php
function string(string $str) : Parser
```


### stringI

Parse a non-empty string, case-insensitive and case-preserving. On success it returns the string cased as the
actually parsed input.
eg stringI("foobar")->run("foObAr") will succeed with "foObAr"



```php
function stringI(string $str) : Parser
```



---

## ParseResult Instance Methods

### output

```php
public function output()
```


### append

```php
public function append(ParseResult $other) : ParseResult
```


### map

Map a function over the output




```php
public function map(callable $transform) : ParseResult
```


### alternative

Return the first successful ParseResult if any, and otherwise return the first failing one.



```php
public function alternative(ParseResult $other) : ParseResult
```


### continueWith

```php
public function continueWith(Parser $parser) : ParseResult
```



---

## Parser Instance Methods

### recurse

Recurse on a parser. Used in combination with {@see recursive()}. After calling this method, this parser behaves
like a regular parser.

```php
public function recurse(Parser $parser) : Parser
```


### run

Run the parser on an input


```php
public function run(string $input) : ParseResult
```


### optional

Optionally parse something, but still succeed if the thing is not there.



```php
public function optional() : Parser
```


### or

Try the first parser, and failing that, try the second parser. Returns the first succeeding result, or the first
failing result.

Caveat: The order matters!
string('http')->or(string('https')



```php
public function or(Parser $other) : Parser
```


### followedBy

Alias for `sequence()`. Parse something, then follow by something else. Ignore the result of the first parser and return the result of the
second parser.




```php
public function followedBy(Parser $second) : Parser
```


### sequence

Parse something, then follow by something else. Ignore the result of the first parser and return the result of the
second parser.




```php
public function sequence(Parser $second) : Parser
```


### label

Label a parser. When a parser fails, instead of a generated error message, you'll see your label.
eg (char(':')->followedBy(char(')')).followedBy(char(')')).


```php
public function label(string $label) : Parser
```


### bind

Create a parser that takes the output from the first parser (if successful) and feeds it to the callable. The
callable must return another parser. If the first parser fails, the first parser is returned.




```php
public function bind(callable $f) : Parser
```


### map

Map a function over the parser (which in turn maps it over the result).




```php
public function map(callable $transform) : Parser
```


### continueFrom

Take the remaining input from the result and parse it

```php
public function continueFrom(ParseResult $result) : ParseResult
```


### construct

Construct a class with thee parser's output as the constructor argument




```php
public function construct(string $className) : Parser
```


### append

Combine the parser with another parser of the same type, which will cause the results to be appended.



```php
public function append(Parser $other) : Parser
```


### try

Try to parse the input, or throw an exception;



```php
public function try(string $input) : ParseResult
```


### apply

Sequential application.

The first parser must be of type Parser<callable(T2):T3>.

apply :: f (a -> b) -> f a -> f b





```php
public function apply(Parser $parser) : Parser
```


### thenIgnore

Sequence two parsers, and return the output of the first one, ignore the second.




```php
public function thenIgnore(Parser $other) : Parser
```



---

## ParserFailure exception

### got

The input that the parser encountered when it failed.

```php
public function got() : string
```


### expected

Information about what the parser expected at the position where it failed.

```php
public function expected() : string
```



---

